* Webアプリケーションエンジニアのためのバッチ処理・設計ハンドブック

** はじめに
*** TODO まえがき

    バッチ処理というのはそれ単体で勉強しようとするとなかなかどこから勉強したらいいのかわからないことが現状です。
    エンジニアのスキルや経験がいわゆるWeb系と言われる、いざバッチ処理を実装しようとした時に基本的なノウハウを知らないまま書いてしまうのではないでしょうか。

    とかなんとか。

*** 本書の目的

    バッチ処理について暗黙知を持たない組織において、バッチ処理を開発することになったエンジニアの助けとなること。
    運用しやすく、可用性が高く、耐障害性に優れたバッチ処理の開発ノウハウを特定の言語・フレームワーク・実行エンジンに依存しないかたちで、体系的に身につけることを目的としています。

*** 対象読者

    Webアプリケーションについて開発経験があるが、バッチ処理について運用まで考慮した開発を行う自信が持てないエンジニアを対象としています。
    勉強しようにも学習リソースに到達できない、あるいはリソースが英語だったり学術的で難しいので実際問題として納期までにそれら文献の理解が困難な方も対象としています。
    つまり、過去の著者自身がメインターゲットとなります。

*** 注意

    著者は社会インフラ・金融・運輸・医療などの人々の生活・生死に強く関わるシステムを手掛けた経験は"ありません"。
    従って、そのようなミッションクリティカルな業務バッチ処理を開発する際に本書の内容を適用できるどうかわかりません。
    これらの分野のバッチ処理に本書の内容を適用すべきかどうかは開発者ご自身の判断でお願いします。
    
** バッチ処理とは

   バッチ処理の本書での定義や概要を書く

** 起動タイミング

   バッチ処理の起動タイミングについては大きく二つ種類があります。
   定時起動かトリガー起動です。

*** 定時起動

    バッチの定時起動は年〜秒の単位で周期的（サイクリック・cyclic）に行われるものを指します。
    秒単位の定時起動のバッチ処理というのも定義上はありえますが、なかなかお目にかかることはないでしょう。

    実現手法としては規模の小さい段階では Linux の cron や Windows のタスクスケジューラを使われることが多いです。

**** TODO 世の中のジョブスケジューラの一覧を書く？

**** 定時起動の呼び方

     組織によっていろいろな呼び方があるでしょうが組織内で呼び方を統一しておくと戸惑うことがありません。
     筆者が所属した組織では以下の呼び方をしていました。

     | 単位 | 呼び方          |
     |------+-----------------|
     | 年   | 年次バッチ      |
     | 月   | 月次バッチ      |
     | 週   | 週次バッチ      |
     | 日   | 日次バッチ      |
     | 時間 | 毎時バッチ      |
     | 分   | N分おきのバッチ |

     毎時の時に時次と呼ぶのも収まりが悪いし、毎次と書くと単位が抜ける…。
     という些細ながらも微妙な気持ちに配慮した呼称です。
     
**** 定時起動の注意点
     
***** 月次バッチは月初に、重要なものから

      月次バッチは月初に、業務的に重要なものから順にスケジューリングするようにしましょう。
      月末にバッチ処理を実行するのは31日、30日、28日、29日(うるう年)のいつ実行するのか考慮する必要が出てくるのでなるのでなるべく避けるようにしましょう。

***** 1日、0時、0分、キリのいい時間を避ける

      バッチを複数作っていると、月初や、0時、0分などキリのいい時間帯に複数のバッチが意図せずスケジューリングされてしまうことになりがちです。
      そして、同時に複数のバッチ処理を起動しようとしてバッチサーバーがダウンするというパンクするというお寒い状況に陥ることがままあります。
      同時実行するバッチが多いと障害発生した際の原因の切り分けなども困難になることが多いため、バッチそれぞれの重要度・緊急度を判断したうえで分散してスケジューリングしていくようにしましょう。

      高機能なジョブ実行サーバーでは、毎時、日次など周期を指定するとそれより下の単位は適度に分散してくれるものもあります。

***** MEMO
      
         - 定時起動
           - 毎時N分
           - 毎日N時
           - 毎週N曜日
           - 毎月N日
         - トリガー
           - WebUIの操作
           - WebAPIへのリクエスト
           - scpでファイルが置かれる
           - メッセージキュー


*** トリガー起動

    このあたりを詳説する
    - トリガー
      - WebUIの操作
      - WebAPIへのリクエスト
      - scpでファイルが置かれる
      - メッセージキュー

** 入力処理

   システム内部・外部のデータを特定期間・範囲でロードする。
   ロード元はいろいろあるけどだいたいこのあたりだろう。

   - RDBMS
   - CSVファイル
   - XML, JSONその他構造化ファイル
   - ログファイル
   - 画像ファイル
   - バイナリファイル
   - 外部Webサービス
   - SCPからファイル取得or受信
   - メッセージキュー
   
*** CSVファイル

    

*** ファイルの転送

    複数の環境や
    ファイルの転送には様々な方法があるが、逐次取り込みの場合は rsync 

** 加工・変換・集計処理

   ロードしたデータを処理していく。
   処理内容はいろいろあるけど大体このあたりの処理をする。

   - クリーニング・ベリファイ
   - 加工
   - 変換
   - 集計

** 出力処理

   さて、データを加工・集計しても、それをどこかに出力しないと意味がない。
   ので、出力する。出力先はまぁいろいろある。ここが外部へ影響を与える瞬間なので一番怖い。

   - RDBMSへ保存・更新
   - CSVへ保存
   - メール・メッセージを送る
   - 外部Webサービスに送信
   - 次のバッチを起動する


** 要整理

*** TODO データの更新はギリギリまで避ける

    RDBMSなどのばあい、トランザクションで複数のデータを更新する際に早い段階からレコードを一行ずつ更新なんかしたりしていると、
    ロック範囲が広がるばっかりでデッドロックの温床になったりして何もいいことがない。
    一時テーブルなどに変更結果やインサートデータを投入しておいて、更新クエリ一発で対象データをガッツリ書き換える様な実装をするほうがよいだろう。
    ファイルなどの場合も、書き込み途中で次のジョブに参照されるみたいな不幸を避けるために一時テーブルに書き込んでおいて最後にリネームするとかしたほうがよい。
    
*** TODO 可能であれば冪等に実装する

    冪等についてはいろいろなところでかなり触れられているので、特に言うことは無い。
    これをきちんとやっておかないと、集計にバグがあったりデータが届いてないとかで再集計を強いられた時に「じゃぁ、この日次バッチを今年の頭から再集計やっていきますか」というつらいことになる。
    ただ、これは設計センスがかなり問われるし、自分も失敗した経験があるので「可能な限りがんばっていきましょう！」みたいな気持ちがある。

*** TODO 並列化可能なポイントを抑えておく

    バッチ処理は大体時間がかかるからこそバッチ処理になってるのだけど、一連のバッチ処理をナイーブに直列に実行していたらいつまで立っても処理が終わらないということもままある。
    バッチ処理のフェイズ毎だとかユーザー毎に、影響範囲が重なっていなければ並列で実行することで処理が早く終わることもあるので抑えておきましょう。
    ただ、並列処理すると当然負荷も上がる場合が多いので、主目的のサービスが死なないよう最大同時スレッド数など、実行負荷の調整ができる機構を備えておきましょう。

*** TODO 時刻の記録

    バッチの対象とするデータの範囲・開始時刻・終了時刻は必ずログやテーブルに記録しよう。
    ログにはかかった時間も出力するとよい。パフォーマンスの劣化を監視するための指標にできる。
    問題が起きた時に開始時刻・終了時刻から計算するのは面倒なので計算してログに出しておこう。
    RRDToolsなどの運用ツールに放り込みやすいようになってるとよりよい。
    RDBMSに投入するときは、バッチ処理そのもののトランザクションと実行記録を残すためのトランザクションを同一にしていると、処理失敗時に記録用レコードもロールバックされてしまうので、実行記録はログに出力しておくほうがよいだろう。

*** TODO 処理対象範囲を引数で指定可能にする

    不幸なことに障害が数日続くという時があるかもしれない、問題解消後に日次バッチを手動集計します。みたいなときに助かる。
    指定しないときは動かないようにするか適切なデフォルト値を自分で判定するかについては、実装者の好みで決めればよい。

*** TODO ロックによる多重起動禁止

    たとえば /var/lock/hogehoge_batch.pid みたいなファイルがあれば、既にバッチが起動しているので新たに起動したバッチは処理を続行しない。
    みたいな制御を入れておくと多重起動してはいけない処理を重複して実行されずに済む。

    ロックファイルではなくて、DBの設定レコードを見るとかでもよいと思う。
    むしろ、バッチサーバーが複数台にまたがっている場合などは一台のDBでロックをとるほうが安心だ。

*** TODO メンテナンスモードによる起動禁止

    たとえば /var/lock/maintenance みたいなファイルがあれば、メンテナンスモードに入っているため新たに起動したバッチは処理を続行しない。
    みたいな制御を入れておくとリリースや障害対応の際に crontab のコメントアウトし忘れたり、外部からのトリガーが不意に来たりすることがないのでよい。
    停止ファイルではなくて、DBの設定レコードを見るとかでもよいと思う。

    バッチ処理の実行、停止はコントローラブルにしておこう。

*** TODO データの保持期限・削除基準を設ける

    バッチ処理の処理結果や処理の副産物として生成されたファイルとかテーブルの後始末について、カウボーイコーディングをしていたり仕様の検討から漏れてたりで、考慮が抜けてしまう事が多い。

    そのまま残しておくとディスク容量を圧迫するけれど、システムからはほぼ利用される事が無い。
    そういうデータは定期的に消すような処理（これもバッチ処理だ）を忘れずに入れておきましょう。

    法律的な理由で一定期間残さなければならないだとか、実装後半年たったら本当に消してもいいデータなのかどうかよくわからなくなった。
    というケースも多い。最初からデータのライフサイクルは意識しておこう。

*** TODO デーモンの採用基準

    バッチの実行プロセスをデーモンにする理由は、単にカッコイイからだとちょっと弱い。感覚の話でアーキテクチャを決めてはいけない。

    - 起動処理が遅く、期待するレスポンスタイムを満たせない
    - トリガーの頻度が多く、常時起動のほうが負荷を制御しやすい
    - トリガーとなるアクションを常に監視しなければいけない

    みたいな理由をでっちあげて君だけのかっこいいデーモンを作り上げよう。
    面倒なら delayed_job や webアプリサーバーにエンドポイント作る方法でもいい。
    webアプリサーバーに組み込んでしまうと複数のバッチ処理をひとつのインスタンスで実行するということになるので、再起動のタイミングなどが少しシビアになってしまうかもしれない。
    このあたりはトレードオフをきちんと考えておこう。

*** TODO 進捗状況を確認できるようにする

    データのインポート処理、エクスポート処理、集計処理、なんであれ時間のかかるバッチ処理というものは時に異常に時間がかかることがある。
    たとえば出社したらアラートが飛んでおり日時バッチがさっぱり終わっていないことがわかったとしよう。
    障害なのはわかったが遅延の状況を知りたいということがある。

    軽度の遅延であり、すでに90%ほど終わっているのか。（よかった、待てば終わるのでその間に障害報告書を書こう）
    あるいはまだ10%しか終わっていないし1%進捗するのにO(n^2)で時間がかかるようになっているのか。（残念、終わる見込みはない。ジョブをkillして対策を練るプロジェクトチームを結成しよう。ソルジャーではないそのあたりでまごついている人に状況を説明し、障害報告書を書いてもらおう）

    実行する処理のフェイズやデータ量に対して何%まで処理が進んでいるのかをログにつどつど記録しておけば、障害時にそれを元に判断を下せる。
    不幸にもログがなくて判断するための材料がない場合は、モニターと上司と同僚の顔を交互に見つめて誰か声を発するのを待つぐらいしかできない。

*** TODO 異常データ、異常動作のアラート

    バッチ処理というのはコマンド起動であれ、デーモンであれ、運用時の監視やアラート設定から漏れてしまうことが多い。
    そして監視設定から抜けてしまうと、これはユーザーのインタラクションに直接紐付かない場合、誰も気が付かないまま時が過ぎてしまうことがある。
    「このマイナー機能の月次処理なんですが、ここ数ヶ月レポートが更新されていないのですが」
    みたいな問い合わせが来たりする。当然俺達はマヌケでありこの集計は冪等に実装されていないので直近1ヶ月の集計しかできない。障害報告書だ。

    なので、異常データが来たり、異常動作が来た時は速やかにアラートメールなりなんなりで運用管理者に知らせないといけないし、
    「実行されているべき時間帯にきちんと正常起動して正常終了した」ということをログから監視できるようにしたうえで、監視を設定してもらう必要がある。

*** TODO Dry Runオプションの用意

    バッチ処理を実装する際は「処理対象範囲を引数で指定可能にする」ようにしたほうがよいと書いた。
    では、実際に障害発生時にバッチを再実行しようという時、あなたはオペミス無しに一発で実行できるだろうか？
    引数として与える対象日時を計算しているときに同僚が「障害報告書の雛形どこにある？」とか聞いてくるわけなので、当然計算はミスっている。

    いざ、本番で再集計を実行しよう。という直前に、Dry Run オプションで対象処理範囲や本番データに影響を及ぼさない範囲で一部の処理を実行してオペレーションの妥当性を確認できるというのはバッチ処理にとってとっても重要なことなので余裕があればぜひとも実装しよう。

*** TODO リカバリー手順を用意し、リカバリー可能な実装にする

    「可能であれば冪等に実装する」に似ているが、ちょっと意味が違う。
    バッチ処理はマスタなどの重要なデータ変更に直結している部分なので、当然ながら慎重にならなければいけない部分だ。

    失敗時に「マスタデータ全部壊れましたワァ。戻りませんワァ」とか言ってると、こういう場合は障害報告書だけでは済まない。
    ボスがボスのボスと雁首揃えて顧客に謝罪と迅速な対応と恒久対策の約束をし、ちょっと無理な要件とかもねじ込まれて帰ってくることになる。

    と、いうわけでバッチ処理の実行前にマスタ情報などを別の場所にコピーして、バッチ処理が壊れていた時にもリカバリーできるようにしておくと良い。
    そして、コピーするときはコピーした時の引数や時刻情報も付与して何世代か保持しておくとより安心だ。
    壊れているバッチを二回実行して、コピーに壊れたマスタ情報しか残ってなかったとかよく聞くでしょう？

*** TODO ワーキングディレクトリの扱い方

    バッチ処理を行うとき、ファイルシステムであれ、RDBMSであれ一時的なデータ領域が必要になる。
    オーケー、 /tmp/batchTmp をワーキングディレクトリにしよう。ここを使ってくれ。
    みたいなルールにすると、当然 hoge.csv がかち合うことになり、毎時バッチAとBのデータが混ざってつらいことになる。
    一時ファイル名なり、一時テーブル名なりにデータが混濁しないようにぶつからない名前空間を作ってやる必要がある。
    「処理対象範囲を引数で指定可能にする」で指定したパラメータをパス名に含めてやるといいですね。
    あと、一時ファイルや一時テーブルを名前がぶつからないようにしたからといって同一ディレクトリ or 同一スキーマに置くのも避けたほうが良い。
    大量のテーブルやファイルがひとつの名前空間に置かれるとだいたい辛いことになるの。

*** TODO 開発・テスト時と本番時の環境差分を最小にしておく

    これはもうバッチに限らないですね。
    バッチ特有の事情としては本番では連携データの転送用ネットワークが別回線だとかいろいろ揃えようにも揃えられないみたいな話はあるんですが iptables を使うだとかいろいろなツールを駆使し、サーバーの構成からネットワークまで差分を最小にした状態でテストしたいものです。
    最近はIaaSの時代になって比較的そういうのやりやすくなっていいですね。

**** 特に情報無いので削る？

*** TODO アルゴリズム(計算効率)に関するケア

    O(n^2)の話。場合によってはnを細かく刻んだほうがいいはなし。

*** TODO メモリ使用量(空間効率)に関するケア

    カーソルとかウインドウの話を書く

*** TODO トランザクション範囲

    これから考える・辛い記憶を思い出す

*** TODO エラー処理について

    こいつはつらいよ

*** TODO 処理状況のステータス

    JSR読んで考える

*** TODO 連携元遅延を考慮する

    連携元からCSVが届かない時どうするかっていうね

** メモ

   - ですます、である調をどうするか
     - 一旦ですます調ベース
   - クソみたいな逸話や喩え話を入れるか（入れたいけど読みたくない）
     - とりあえず気持よく書いてどんどん削ろう
   - どこまでバッチ処理の重厚サイドの話を書くか
     - JSRでいうJOB、STEP、CHUNK的なものを書くかどうか
     - 自分の学習状況にもよるけど、読者が胃もたれしないラインを見極めたい
   - クックブック・ハンドブック・パターンのようにトピックを並べる形式にするか、体系だてて並べるべきか。
   - 分散・クラウド的な話
     - そもそも自分の経験から外れるからナシ。せいぜい複数スレッド・プロセス・サーバーでの並列処理について書く程度。

** 参考資料

*** JSR-352

    [[https://jcp.org/en/jsr/detail?id=352][PDF]]

*** okachimachiorzさんの

    [[http://d.hatena.ne.jp/okachimachiorz/20120121/1327146544][Asakusaでの設計・実装の方法についてのドキュメント]]

    [[http://www.asakusafw.com/techinfo/methodology.html][バッチ設計と実装ガイド]]

*** wyukawaさんの

    [[http://d.hatena.ne.jp/wyukawa/20150617/1434509706][バッチ処理、ジョブ管理について書いてみるAdd Starhaishi]]

    [[http://d.hatena.ne.jp/wyukawa/20150925/1443166905][バッチ処理の実装方法]]

*** kawasimaさんの
    
    [[http://qiita.com/kawasima/items/ee863f23b4588b9792fb][多い日も安心設計]]

    [[http://qiita.com/advent-calendar/2015/se][システムエンジニア Advent Calendar 2015]]

*** コンポツさん

    [[http://b.hatena.ne.jp/entry/mitomasan.hatenablog.com/entry/2016/02/17/232019][はてぶ1]]
    [[http://b.hatena.ne.jp/entry/mitomasan.hatenablog.com/entry/2016/02/19/004516][はてぶ2]]

*** qiita

    [[http://qiita.com/madilloar/items/67fb6ee0a64a5435bc28][教科書に載っていないけど、よい設計。]]
    
*** 本を書くときの参考

    [[http://azu.github.io/promises-book/][JavaScript Promiseの本]]
    
    [[http://tsuchinoko.dmmlabs.com/?p=2303][技術書、それも売れるやつを書きたい人へ、編集者からのアドバイス]]
